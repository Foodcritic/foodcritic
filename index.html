---
layout: default
title: Foodcritic
rules:
  - code: FC001
    name: Use strings in preference to symbols to access node attributes
    tags:
      - style
      - attributes
    applies_to: '>= 0.7.12'
    summary: |
      This rule has been deprecated. See the discussion against
      [issue #86](https://github.com/acrmp/foodcritic/issues/86) for more
      detail.
  - code: FC002
    name: Avoid string interpolation where not required
    tags:
      - style
      - strings
    summary: |
      When you declare a resource in your recipes you frequently want to
      reference dynamic values such as node attributes. This warning will be
      shown if you are unnecessarily wrapping an attribute reference in a
      string.
    examples:
      - title: Unnecessary string interpolation
        text: This example would match the FC002 rule because the `version` attribute has been unnecessarily quoted.
        code: |
          # Don't do this
          package "mysql-server" do
            version "#{node['mysql']['version']}"
            action :install
          end
      - title: Modified version
        text: 'This modified example would not match the FC002 rule:'
        code: |
          package "mysql-server" do
            version node['mysql']['version']
            action :install
          end

  - code: FC003
    name: Check whether you are running with chef server before using server-specific features
    tags:
      - portability
      - solo
    summary: |
      Chef Server extends the feature-set of a Chef deployment and is probably
      the most popular configuration. It is also possible to run the Chef client
      in a standalone mode with Chef Solo.
      Where your cookbooks make use of features that only exist in a Chef Server
      based setup you should check whether you are running in solo mode.

      * [http://wiki.opscode.com/display/chef/Chef+Solo](http://wiki.opscode.com/display/chef/Chef+Solo)
    examples:
      - title: Does not check for Chef Solo
        text: |
          This example would match the FC003 rule because it does not check if
          it is running in Chef Solo before using search which is a
          server-specific feature.
        code: |
          nodes = search(:node, "hostname:[* TO *] AND chef_environment:#{node.chef_environment}")
      - title: Modified version
        text: 'This modified example would not match the FC003 rule:'
        code: |
          if Chef::Config[:solo]
            Chef::Log.warn("This recipe uses search. Chef Solo does not support search.")
          else
            nodes = search(:node, "hostname:[* TO *] AND chef_environment:#{node.chef_environment}")
          end
  - code: FC004
    name: Use a service resource to start and stop services
    tags:
      - style
      - services
    summary: |
      This warning is shown if you are starting or stopping a service using the
      Chef `execute` resource rather than the more idiomatic `service` resource.
      You can read more about the service resource here:

      * [http://wiki.opscode.com/display/chef/Resources#Resources-Service](http://wiki.opscode.com/display/chef/Resources#Resources-Service)
    examples:
      - title: Uses execute to control a service
        text: |
          This example would match the FC004 rule because it uses `execute` for
          service control. There is no reason to use execute because the service
          resource exposes the `start_command` attribute to give you full
          control over the command issued.
        code: |
          # Don't do this
          execute "start-tomcat" do
            command "/etc/init.d/tomcat6 start"
            action :run
          end
      - title: Modified version
        text: 'This modified example would not match the FC004 rule:'
        code: |
          service "tomcat" do
            action :start
          end
  - code: FC005
    name: Avoid repetition of resource declarations
    tags:
      - style
    summary: |
      When writing Chef recipes you have the full power of Ruby at your
      disposal. One of the cases where this is helpful is where you need to
      declare a large number of resources that only differ in a single attribute
      - the canonical example is installing a long list of packages.
    examples:
      - title: Unnecessarily repetitive
        text: |
          This example matches the FC005 rule because all the resources of type
          `package` differ only in a single attribute - the name of the package
          to be upgraded. This rule is very simple and looks only for resources
          that all differ in only a single attribute. For example - if only one
          of the packages specified the version then this rule would not match.
        code: |
          # You could do this
          package "erlang-base" do
            action :upgrade
          end
          package "erlang-corba" do
            action :upgrade
          end
          package "erlang-crypto" do
            action :upgrade
          end
          package "rabbitmq-server" do
            action :upgrade
          end
      - title: Modified version
        text: |
          This modified example would not match the FC005 rule. It takes
          advantage of the fact that Chef processes recipes in two distinct
          phases:

          * [http://wiki.opscode.com/display/chef/Anatomy+of+a+Chef+Run](http://wiki.opscode.com/display/chef/Anatomy+of+a+Chef+Run)

          Don't worry about changing your recipe if it already does what you
          want - the amount of Ruby syntactic sugar to apply is very much a
          matter of personal taste. Note that this rule also isn't clever enough
          yet to detect if your resources are wrapped in a control structure and
          not suitable for 'rolling up' into a loop.
        code: |
          # It's shorter to do this
          %w{erlang-base erlang-corba erlang-crypto rabbitmq-server}.each do |pkg|
            package pkg do
              action :upgrade
            end
          end
  - code: FC006
    name: Mode should be quoted or fully specified when setting file permissions
    tags:
      - correctness
      - files
    summary: |
      When setting file or directory permissions via the mode attribute you
      should either quote the octal number or ensure it is specified to five
      digits. Otherwise the permissions that are set after Ruby coerces the
      number may not match what you expect.
    examples:
      - title: File mode won't be interpreted correctly
        code: |
          # Don't do this
          directory "/var/lib/foo" do
            owner "root"
            group "root"
            mode 644
            action :create
          end
      - title: Modified versions
        text: 'These modified examples would not match the FC006 rule:'
        code: |
          # This is ok
          directory "/var/lib/foo" do
            owner "root"
            group "root"
            mode "644"
            action :create
          end

          # And so is this
          directory "/var/lib/foo" do
            owner "root"
            group "root"
            mode 00644
            action :create
          end
  - code: FC007
    name: Ensure recipe dependencies are reflected in cookbook metadata
    tags:
      - correctness
      - metadata
    summary: |
      This warning is shown when you include a recipe that is not in the current
      cookbook and not defined as a dependency in your cookbook metadata. This
      is potentially a big problem because things will blow up if the necessary
      dependency cannot be found when Chef tries to converge your node. For more
      information refer to the Chef wiki metadata page:

      * [http://wiki.opscode.com/display/chef/Metadata](http://wiki.opscode.com/display/chef/Metadata)

      The fix is to declare the cookbook of the recipe you are including as a
      dependency in your `metadata.rb` file.

      You may also see this warning if foodcritic has not been able to infer the
      name of your cookbook correctly when the cookbook directory does not match
      the name of the cookbook specified in the include.
    examples:
      - title: Example depency on another cookbook
        text: |
          Assuming you have a recipe that had the following line:
        code: |
          include_recipe "apache2::default"
      - title: Adding metadata dependency for Chef
        text: |
          Then to remove this warning you would add the `apache2` cookbook as a
          dependency to your own cookbook metadata in the `metadata.rb` file at
          the root of your cookbook.
        code: |
          depends "apache2"
  - code: FC008
    name: Generated cookbook metadata needs updating
    tags:
      - style
      - metadata
    summary: |
      This warning is shown if you used `knife cookbook create` to create a new
      cookbook and didn't override the maintainer and maintainer email. You need
      to set these to real values in `metadata.rb` or run knife again with the
      real values.

      * [http://wiki.opscode.com/display/chef/Managing+Cookbooks+With+Knife#ManagingCookbooksWithKnife-create](http://wiki.opscode.com/display/chef/Managing+Cookbooks+With+Knife#ManagingCookbooksWithKnife-create)
    examples:
      - title: Maintainer metadata is boilerplate default
        code: |
          # Don't do this
          maintainer "YOUR_COMPANY_NAME"
          maintainer_email "YOUR_EMAIL"
          license "All rights reserved"
          description "Installs/Configures example"
          long_description IO.read(File.join(File.dirname(__FILE__), 'README.rdoc'))
          version "0.0.1"
      - title: Modified version
        text: 'This modified example would not match the FC008 rule:'
        code: |
          maintainer "Example Ltd"
          maintainer_email "postmaster@example.com"
          license "All rights reserved"
          description "Installs/Configures example"
          long_description IO.read(File.join(File.dirname(__FILE__), 'README.rdoc'))
          version "0.0.1"
  - code: FC009
    name: Resource attribute not recognised
    tags:
      - correctness
    summary: |
        This warning is likely to mean that your recipe will fail to run when
        you attempt to converge. Your recipe may be syntactically valid Ruby,
        but the attribute you have attempted to set on a built-in Chef resource
        is not recognised. This is commonly a typo or you need to check the
        documentation to see what the attribute you are trying to set is called:

        * [http://wiki.opscode.com/display/chef/Resources](http://wiki.opscode.com/display/chef/Resources)
    examples:
      - title: Resource with an unrecognised attribute
        text: |
          This example matches the FC009 rule because `punter` is not a
          recognised attribute for the file resource.
        code: |
          # Don't do this
          file "/tmp/something" do
            punter "root"
            group "root"
            mode "0755"
            action :create
          end
      - title: Modified version
        text: |
          Checking the documentation we can see the correct attribute is
          `owner`.
        code: |
          file "/tmp/something" do
            owner "root"
            group "root"
            mode "0755"
            action :create
          end
  - code: FC010
    name: Invalid search syntax
    tags:
      - correctness
      - search
    summary: |
      The search syntax used is not recognised as valid Lucene search criteria.
      This is commonly because you have made a typo or are not escaping special
      characters in the query syntax.

      * [http://wiki.opscode.com/display/chef/Search#Search-QuerySyntax](http://wiki.opscode.com/display/chef/Search#Search-QuerySyntax)

      Note that this rule will not identify syntax errors in searches composed
      of subexpressions. It checks only for literal search strings.
    examples:
      - title: Unescaped search syntax
        text: |
          This example matches the FC010 rule because search metacharacters -
          in this case the square brackets - have not been properly escaped.
        code: |
          # Don't do this
          search(:node, 'run_list:recipe[foo::bar]') do |matching_node|
            puts matching_node.to_s
          end
      - title: Modified version
        text: |
          With the characters escaped this will no longer match the rule.
        code: |
          search(:node, 'run_list:recipe\[foo\:\:bar\]') do |matching_node|
            puts matching_node.to_s
          end
  - code: FC011
    name: Missing README in markdown format
    tags:
      - style
      - readme
    summary: |
      The [Opscode Community site](http://community.opscode.com/) will now
      render your cookbook README documentation inline - [see this example for
      the mysql cookbook](http://community.opscode.com/cookbooks/mysql).

      Your README needs to be in
      [Markdown format](http://daringfireball.net/projects/markdown/syntax) for
      this to work. This rule will match any cookbook that does not have a
      `README.md` file in the root directory.
  - code: FC012
    name: Use Markdown for README rather than RDoc
    tags:
      - style
      - readme
    summary: |
      Writing cookbook documentation in RDoc has been deprecated in favour of
      [Markdown format](http://daringfireball.net/projects/markdown/syntax).
      This rule will match any cookbook that has a `README.rdoc` file in the
      root directory.
  - code: FC013
    name: Use file_cache_path rather than hard-coding tmp paths
    tags:
      - style
      - files
    summary: |
      This warning means that you have hard-coded a file download path in your
      cookbook to a temporary directory. This can be a problem on boxes built
      with a small `/tmp` mount point. Chef has its own configuration option
      `file_cache_path` you should use instead:

      * [http://wiki.opscode.com/display/chef/Chef+Configuration+Settings#ChefConfigurationSettings-filecachepath](http://wiki.opscode.com/display/chef/Chef+Configuration+Settings#ChefConfigurationSettings-filecachepath)
    examples:
      - title: Downloading to a hard-coded temp directory
        text: |
          This example matches the FC013 rule because it hard-codes the download
          path to `/tmp`.
        code: |
          # Don't do this
          remote_file "/tmp/large-file.tar.gz" do
            source "http://www.example.org/large-file.tar.gz"
          end
      - title: Modified version
        text: 'To remove this warning use the configured `file_cache_path`:'
        code: |
          remote_file "#{Chef::Config[:file_cache_path]}/large-file.tar.gz" do
            source "http://www.example.org/large-file.tar.gz"
          end
  - code: FC014
    name: Consider extracting long ruby_block to library
    tags:
      - style
      - libraries
    summary: |
      Your cookbook has a fairly long `ruby_block` resource. Long `ruby_block`
      resources are often candidates for extraction to a separate module or
      class under the `libraries` directory.

      * [http://wiki.opscode.com/display/chef/Libraries](http://wiki.opscode.com/display/chef/Libraries)
  - code: FC015
    name: Consider converting definition to a LWRP
    tags:
      - style
      - definitions
      - lwrp
    summary: |
      Chef definitions are an older approach to creating a higher-level
      abstraction for a group of resources. Unlike LWRPs they are not first
      class resources and cannot receive notifications. You should prefer LWRPs
      for new development.

      * [http://wiki.opscode.com/display/chef/Definitions](http://wiki.opscode.com/display/chef/Definitions)
      * [http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+(LWRP)](http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+%28LWRP%29)
  - code: FC016
    name: LWRP does not declare a default action
    tags:
      - correctness
      - lwrp
    applies_to: '>= 0.7.12'
    summary: |
      This warning means that the LWRP does not declare a default action. You
      should normally define a default action on your resource to avoid
      confusing users. Most resources have an intuitive default action.

      * [http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+(LWRP)#LightweightResourcesandProviders%28LWRP%29-DefaultAction](http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+%28LWRP%29#LightweightResourcesandProviders%28LWRP%29-DefaultAction)
    examples:
      - title: Resource without a default action
        text: |
          This example matches the FC016 rule because it does not declare a
          default action.
        code: |
          # Don't do this
          actions :create
      - title: Modified version
        text: |
          With a default action specified this warning will no longer be
          displayed.
        code: |
          actions :create

          # Chef 0.10.10 or greater
          default_action :create
          
          # In earlier versions of Chef the LWRP DSL doesn't support specifying
          # a default action, so you need to drop into Ruby.
          def initialize(*args)
            super
            @action = :create
          end
  - code: FC017
    name: LWRP does not notify when updated
    tags:
      - correctness
      - lwrp
    applies_to: '>= 0.7.12'
    summary: |
      This warning means that the LWRP will not currently trigger notifications
      to other resources. This can be a source of difficult to track down bugs.

      * [http://wiki.opscode.com/display/chef/Resources#Resources-Notifications](http://wiki.opscode.com/display/chef/Resources#Resources-Notifications)
    examples:
      - title: Provider that does not send notifications
        text: |
          This example matches the FC017 rule because it does not mark that its
          state has changed and will therefore not send notifications.
        code: |
          # Don't do this
          action :create do
            # create action implementation
          end
      - title: Modified version
        text: |
          The call to `updated_by_last_action` ensures that notifications will
          work correctly.
        code: |
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers
            new_resource.updated_by_last_action(true)
          end
  - code: FC018
    name: LWRP uses deprecated notification syntax
    tags:
      - style
      - lwrp
      - deprecated
    applies_to: '>= 0.9.10'
    examples:
      - title: Provider uses deprecated syntax
        text: |
          This example matches the FC018 rule because it uses the old syntax for
          indicating it has been updated.
        code: |
          # Don't do this
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers, but I'm using
            # a deprecated syntax
            new_resource.updated = true
          end

          # Also don't do this
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers, but I'm using
            # a deprecated syntax
            @updated = true
          end
      - title: Modified version
        text: |
          This example uses the newer syntax and will not raise the warning.
        code: |
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers
            new_resource.updated_by_last_action(true)
          end
  - code: FC019
    name: Access node attributes in a consistent manner
    tags:
      - style
      - attributes
    summary: |
      Node attributes can be accessed in multiple ways in Chef. This warning is
      shown when a cookbook is not consistent in the approach it uses to access
      attributes. It is not displayed for variations between cookbooks.
    examples:
      - title: Recipe mixes symbols and strings for accessing node attributes
        code: |
          # Don't do this
          node[:apache][:dir] = '/etc/apache2'
          
          directory node['apache']['dir'] do
            owner 'apache'
            group 'apache'
            action :create
          end
      - title: Modified version
        code: |
          node['apache']['dir'] = '/etc/apache2'
          
          directory node['apache']['dir'] do
            owner 'apache'
            group 'apache'
            action :create
          end
  - code: FC020
    name: Conditional execution string attribute looks like Ruby
    tags:
      - correctness
    summary: |
      This rule has been deprecated due to the frequency of false positives.
      See the discussion against
      [issue #30](https://github.com/acrmp/foodcritic/issues/30) for more
      detail.
  - code: FC021
    name: Resource condition in provider may not behave as expected
    tags:
      - correctness
      - lwrp
    applies_to: '>= 0.10.6'
    summary: |
      A change introduced in Chef 0.10.6 means that conditions may not work as
      expected for resources redeclared with the same name. If your LWRP defines
      a resource and that resource:

      * Has an [associated condition](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
        which references a resource attribute. AND
      * The resource has a fixed name.

      Then you will likely find that only the first resource will be applied. See this ticket for more background:

      * [http://tickets.opscode.com/browse/CHEF-2812](http://tickets.opscode.com/browse/CHEF-2812)
    examples:
      - title: Resource condition will be evaluated only once
        text: |
          Because the `feed_pet` resource will have the same name across all
          instances of your LWRP, the condition will only be checked for the
          first resource.
        code: |
          # Don't do this
          action :feed do
            execute "feed_pet" do
              command "echo 'Feeding: #{new_resource.name}'; touch '/tmp/#{new_resource.name}'"
              not_if { ::File.exists?("/tmp/#{new_resource.name}")}
            end
          end
      - title: Modified version
        text: |
          By making the resource name change for each unique instance of our
          LWRP instance we avoid this behaviour.
        code: |
          action :feed do
            execute "feed_pet_#{new_resource.name}" do
              command "echo 'Feeding: #{new_resource.name}'; touch '/tmp/#{new_resource.name}'"
              not_if { ::File.exists?("/tmp/#{new_resource.name}")}
            end
          end
  - code: FC022
    name: Resource condition within loop may not behave as expected
    tags:
      - correctness
    applies_to: '>= 0.10.6'
    summary: |
      A change introduced in Chef 0.10.6 means that conditions may not work as
      expected for resources declared within a loop. If your recipe defines a
      resource and that resource:

      * Has an [associated condition](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
        which references a block variable. AND
      * The resource has a fixed name.

      Then you will likely find that only the first resource will be applied. See this ticket for more background:

      * [http://tickets.opscode.com/browse/CHEF-2812](http://tickets.opscode.com/browse/CHEF-2812)
    examples:
      - title: Resource condition will be evaluated only once
        text: |
          Because the feed_pet resource will have the same name for every
          iteration of the loop, the condition will only be checked for the
          first resource.
        code: |
          # Don't do this
          %w{rover fido}.each do |pet_name|
            execute "feed_pet" do
              command "echo 'Feeding: #{pet_name}'; touch '/tmp/#{pet_name}'"
              not_if { ::File.exists?("/tmp/#{pet_name}")}
            end
          end
      - title: Modified version
        text: |
          By making the resource name change for each iteration of the loop we avoid this behaviour.
        code: |
          %w{rover fido}.each do |pet_name|
            execute "feed_pet_#{pet_name}" do
              command "echo 'Feeding: #{pet_name}'; touch '/tmp/#{pet_name}'"
              not_if { ::File.exists?("/tmp/#{pet_name}")}
            end
          end
  - code: FC023
    name: Prefer conditional attributes
    tags:
      - style
    summary: |
      This warning means you have surrounded a resource with an `if` or `unless`
      rather than defining the condition directly on the resource itself. Note
      that this warning is only raised for single resources as you could
      reasonably enclose multiple resources in a condition like this for
      brevity.

      [Jay Feldblum](https://github.com/yfeldblum) has
      [expressed criticism](http://community.opscode.com/chat/chef/2012-06-19#id-138584)
      of this rule because the effect is that resources are defined
      unnecessarily and ignored only at run-time. His view is that it is cleaner
      to use standard Ruby conditionals to avoid defining them in the first place.
    examples:
      - title: Resource enclosed in a condition
        text: |
          This example matches the FC023 rule because it encloses a rule within
          a condition, rather than using the built-in Chef `not_if` or `only_if`
          conditional execution attributes.

          * [http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
        code: |
          # Don't do this
          if node['foo'] == 'bar'
            service "apache" do
              action :enable
            end
          end
      - title: Modified version
        text: |
          You can avoid the warning above with more idiomatic Chef that
          specifies the condition above as an attribute on the resource:
        code: |
          service "apache" do
            action :enable
            only_if { node['foo'] == 'bar' }
          end
  - code: FC024
    name: Consider adding platform equivalents
    tags:
      - portability
    summary: |
      This warning is shown when:

      * you have a conditional statement in your cookbook based on the platform
        of the node
      * and at least two platforms are included as equivalent in your
        conditional
      * and the conditional does not include a platform known to belong to the
        same family

      If you are using
      [Ohai 0.6.12](http://www.opscode.com/blog/2012/03/22/ohai-0-6-12-released/)
      or greater you should probably use `platform_family` instead. Otherwise
      for the greatest portability consider adding the missing platforms to
      your conditional.
    examples:
      - title: Case statement has a subset of platform flavours
        text: |
          This example matches the FC024 rule because it includes a `case`
          statement that matches more than one flavour of a platform family
          but omits other popular flavours from the same family.
        code: |
          # The RHEL platforms branch below omits popular distributions
          # including Amazon Linux.
          case node[:platform]
            when "debian", "ubuntu"
              package "foo" do
                action :install
              end
            when "centos", "redhat"
              package "bar" do
                action :install
              end
            end
          end
      - title: Modified version
        text: |
          This warning is no longer raised when the other common equivalent
          RHEL-based distributions have been added to the `when`.
        code: |
          case node[:platform]
            when "debian", "ubuntu"
              package "foo" do
                action :install
              end
            when "centos", "redhat", "amazon", "scientific"
              package "bar" do
                action :install
              end
            end
  - code: FC025
    name: Prefer chef_gem to compile-time gem install
    tags:
      - style
      - deprecated
    applies_to: '>= 0.10.10'
    summary: |
      This warning is shown if:
      * you have a cookbook that installs a Rubygem for use from Chef
      * the cookbook uses the
        [compile-time gem install trick](http://www.opscode.com/blog/2009/06/01/cool-chef-tricks-install-and-use-rubygems-in-a-chef-run/)
        which is deprecated from Chef 0.10.10 and is replaced by the first class
        `chef_gem` resource.
    examples:
      - title: Manual compile-time installation
        text: |
          This example matches the FC025 rule because it uses the older
          approach for installing a gem so that it is available in the current
          run.
        code: |
          r = gem_package "mysql" do
            action :nothing
          end

          r.run_action(:install)
          Gem.clear_paths
      - title: Modified version
        text: |
          Use `chef_gem` to install the gem to avoid this warning.
        code: |
          chef_gem "mysql"
  - code: FC026
    name: Conditional execution block attribute contains only string
    tags:
      - correctness
    applies_to: '>= 0.7.4'
    summary: |
      This warning is shown if you have a conditional attribute declared on a
      resource as a block that contains only a single string.
    examples:
      - title: Conditional attribute returns a string
        text: |
          This example matches the FC026 rule because it returns a string from
          the block. This will always evalute to true, and often indicates that
          you are trying to run a command rather than execute a Ruby block as
          your condition.
        code: |
          # Don't do this
          template "/etc/foo" do
            mode "0644"
            source "foo.erb"
            not_if { "test -f /etc/foo" }
          end
      - title: Modified version
        text: |
          If the intention is to run the string as an operating system command
          then remove the block surrounding the command.
        code: |
          template "/etc/foo" do
            mode "0644"
            source "foo.erb"
            not_if "test -f /etc/foo"
          end
  - code: FC027
    name: Resource sets internal attribute
    tags:
      - correctness
    summary: |
      This warning is shown if you set an attribute on a Chef resource that is
      technically accessible but should not be set in normal usage.
      To avoid this warning allow Chef to set the value of the internal
      attribute rather than setting it yourself.
    examples:
      - title: Service resource sets internal attribute
        text: |
          This example matches the FC027 rule because it sets the `running`
          attribute on a service resource. This attribute should normally be
          set by the provider itself and not in normal recipe usage.
        code: |
          # Don't do this
          service "foo" do
            running true
          end
      - title: Modified version
        text: |
          In this particular example you can achieve the same effect by using
          the service `:start` action.
        code: |
          service "foo" do
            action :start
          end
  - code: FC028
    name: "Incorrect #platform? usage"
    tags:
      - correctness
    summary: |
      This warning is shown if you attempt to use the `platform?` Chef built-in
      method as `node.platform?`. Because of the way Chef attributes work the
      later approach will not error but will do the wrong thing which may
      result in resources you had intended to apply only to a single platform
      instead being applied to all platforms.
    examples:
      - title: Incorrect attempt to use platform? method
        text: |
          This example matches the FC028 rule because the `platform?` method
          is incorrectly prefixed with `node`.
        code: |
          # Don't do this
          file "/etc/foo" do
            only_if { node.platform?("commodore64") }
          end
      - title: Modified version
        text: |
          Remove the leading `node.` from the use of `platform?` to resolve
          this warning.
        code: |
          file "/etc/foo" do
            only_if { platform?("commodore64") }
          end
  - code: FC029
    name: No leading cookbook name in recipe metadata
    tags:
      - correctness
      - metadata
    summary: |
      This warning is shown if you declare a recipe in your cookbook metadata
      without including the cookbook name as a prefix.
    examples:
      - title: Recipe declared without cookbook name prefix
        text: |
          This example matches the FC029 rule because the metadata declares a
          recipe without prefixing it with the name of the current cookbook.
        code: |
          # Don't do this
          name "example"
          version "1.2.3"
          recipe "default", "Installs Example"
      - title: Modified version
        text: |
          This modified example would not match the FC029 rule:
        code: |
          name "example"
          version "1.2.3"
          recipe "example::default", "Installs Example"
  - code: FC030
    name: Cookbook contains debugger breakpoints
    tags:
      - annoyances
    summary: |
      [Pry is a fantastic tool](http://pry.github.com/) for interactive
      exploration of a running Ruby program. You can place breakpoints in your
      cookbook code that will launch a Pry console. This warning is shown when
      your cookbook code contains these breakpoints, as failing to remove these
      will cause your Chef run to halt.

      This rule currently only checks for use of `binding.pry` and not the Chef
      built-in `breakpoint` resource which is never used outside of
      [Shef](http://wiki.opscode.com/display/chef/Shef).
    examples:
      - title: Recipe includes breakpoint
        text: |
          This example matches the FC030 rule because it includes a Pry
          breakpoint declared with `binding.pry`.
        code: |
          # Don't do this
          template "/etc/foo" do
            source "foo.erb"
          end
          binding.pry
      - title: Modified version
        text: |
          This modified example would not match the FC030 rule:
        code: |
          template "/etc/foo" do
            source "foo.erb"
          end
  - code: FC031
    name: Cookbook without metadata file
    tags:
      - correctness
      - metadata
    summary: |
      Chef cookbooks normally include a `metadata.rb` file which can be used
      to express a
      [wide range of metadata about a cookbook](http://wiki.opscode.com/display/chef/Metadata).
      This warning is shown when a directory appears to contain a cookbook, but
      does not include the expected `metadata.rb` file at the top-level.
  - code: FC032
    name: Invalid notification timing
    tags:
      - correctness
      - notifications
    summary: |
      [Chef notifications](http://wiki.opscode.com/display/chef/Resources#Resources-Notifications)
      allow a resource to define that it should be actioned when another
      resource changes state.

      Notification timing can be controlled and set to `immediate`, or `delayed`
      until the end of the Chef run. This warning is shown when the timing
      specified is not recognised.
    examples:
      - title: Notification timing is invalid
        text: |
          This example matches the FC032 rule because it specifies an invalid
          notification timing.
        code: |
          # Don't do this
          template "/etc/foo" do
            notifies :restart, "service[foo]", :imediately
          end
      - title: Modified version
        text: |
          This modified example would not match the FC032 rule because the
          mispelt timing has been corrected.
        code: |
          template "/etc/foo" do
            notifies :restart, "service[foo]", :immediately
          end
  - code: FC033
    name: Missing template
    tags:
      - correctness
    summary: |
      This warning is shown when the erb template associated with a
      [template resource](http://wiki.opscode.com/display/chef/Resources#Resources-Template)
      cannot be found.
  - code: FC034
    name: Unused template variables
    tags:
      - correctness
    summary: |
      This warning is shown when one or more variables passed into a template
      by a [template resource](http://wiki.opscode.com/display/chef/Resources#Resources-Template)
      are not then used within the template.

      This is often a sign that a template still contains hard-coded values that
      you intended to parameterise.
    examples:
      - title: Unused template variables
        text: |
          This example matches the FC034 rule because it passes two variables
          to the template, of which only the first is used.
        code: |
          template "/etc/foo/config.conf" do
            source "config.conf.erb"
            variables(
              'config_var_a' => node['config']['config_var_a']
              'config_var_b' => node['config']['config_var_b']
            )
          end


          # config.conf.erb
          var_a=<%= @config_var_a %>
      - title: Modified version
        text: |
          This modified example would not match the FC034 rule becuse the
          template has been updated to include both variables passed through.
        code: |
          template "/etc/foo/config.conf" do
            source "config.conf.erb"
            variables(
              'config_var_a' => node['config']['config_var_a']
              'config_var_b' => node['config']['config_var_b']
            )
          end

          # config.conf.erb
          var_a=<%= @config_var_a %>
          var_b=<%= @config_var_b %>
  - code: FC035
    name: Template uses node attribute directly
    tags:
      - style
    summary: |
      This rule has been deprecated. See the discussion against
      [issue #60](https://github.com/acrmp/foodcritic/issues/60) for more
      detail.
  - code: FC037
    name: Invalid notification action
    tags:
      - correctness
    summary: |
      This warning is shown when a resource
      [notifies](http://wiki.opscode.com/display/chef/Resources#Resources-Notifications)
      another resource to take an action, but the action is invalid for the
      target resource type.
    examples:
      - title: Invalid notification action
        text: |
          This example matches the FC037 rule because `:activate_turbo_boost` is
          not a valid action for services.
        code: |
          # Don't do this
          template "/etc/foo.conf" do
            notifies :activate_turbo_boost, "service[foo]"
          end
      - title: Modified version
        text: |
          This modified example would not match the FC037 rule because the
          action has been corrected.
        code: |
          template "/etc/foo.conf" do
            notifies :restart, "service[foo]"
          end

api_methods: 
  - name: attribute_access
    description: |
      Find attributes accesses by type.

      You might use this method to enforce local style rules on how attributes
      are accessed.
    examples: |
      # All references to attributes using strings
      # For example: node['foo']
      attribute_access(ast, :type => :string)
      
      # All references to attributes using symbols
      # For example: node[:foo]
      attribute_access(ast, :type => :symbol)
      
      # All references to attributes using dots (vivified methods)
      # For example: node.foo
      attribute_access(ast, :type => :symbol)
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: param
        type: Hash
        name: options
        description: The options hash (see allowed values below)
      - category: option
        type: Symbol
        name: ':type'
        description: |
          The approach used to access the attributes. One of `:string`,
          `:symbol`, `:vivified` or `:any`.
      - category: option
        type: Boolean
        name: ':ignore_calls'
        description: |
          Exclude attribute accesses that mix strings/symbols with dot notation.
          Defaults to `false`.
      - category: return
        type: Array
        description: The matching nodes if any
  - name: checks_for_chef_solo?
    description: |
      Does the specified recipe check for
      [Chef Solo](http://wiki.opscode.com/display/chef/Chef+Solo)?

      You can use this to check for the portability of the recipe between
      Chef Server and Chef Solo.
    examples: |
      # Returns true if the recipe checks for Chef Solo before using
      # server-specific functionality.
      checks_for_chef_solo?(ast)
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: return
        type: Boolean
        description: |
          True if there is a test for `Chef::Config[:solo]` in the recipe
  - name: chef_dsl_methods
    description: |
      The set of methods in the Chef DSL.

      You can use this to see if a method reference is part of the Chef DSL or
      defined in a cookbook.
    examples: |
      # Is search a method in the Chef DSL?
      chef_dsl_methods.include?(:search)
      => true
    signature:
      - category: return
        type: Array
        description: |
          Array of method symbols
  - name: chef_solo_search_supported?
    description: |
      Is the [chef-solo-search](https://github.com/edelight/chef-solo-search) library available?

      Will return `true` if any cookbook in the cookbook tree relative to the
      specified recipe includes the chef-solo-search library. You can use this
      to see if search is available in Chef Solo mode.
    examples: |
      # True if chef_solo_search is supported
      chef_solo_search_supported?('foo/recipes/default.rb')
    signature:
      - category: param
        type: String
        name: recipe_path
        description: The path to the current recipe
      - category: return
        type: Boolean
        description: True if the chef-solo-search library is available.
  - name: cookbook_name
    description: |
      The name of the cookbook containing the specified file.

      You can use this method in rules that need to work out if recipe code
      refers to the current cookbook: for example when looking at
      `included_recipe` statements or LWRP usage.
    examples: |
      cookbook_name('foo/recipes/default.rb')
      => "foo"
    signature:
      - category: param
        type: String
        name: file
        description: The file in the cookbook
      - category: return
        type: String
        description: The name of the containing cookbook
  - name: declared_dependencies
    description: |
      The dependencies declared in cookbook metadata.

      You can use this to check if all dependencies have been declared
      correctly or to find all cookbooks that share a common dependency.
    examples: |
      ast = read_ast('postgresql/metadata.rb')
      declared_dependencies(ast)
      => ["openssl"]
    signature:
      - category: param
        type: Nokogiri::XML::Node
        name: ast
        description: The metadata rb AST
      - category: return
        type: Array
        description: List of cookbooks depended on
  - name: file_match
    description: |
      Create a match for a specified file. Use this if the presence of the file
      triggers the warning rather than content.

      This is an alternative to `match` where you don't have a specific AST
      element to associate the warning with. The call to `file_match` will
      typically be the last line in your rule.
    examples: |
      file_match('foo/recipes/default.rb')
      => {:filename=>"foo/recipes/default.rb",
       :matched=>"foo/recipes/default.rb",
       :line=>1,
       :column=>1}
    signature:
      - category: param
        type: String
        name: file
        description: The filename to create a match for
      - category: return
        type: Hash
        description: Hash with the match details
  - name: find_resources
    description: |
      Find Chef resources of the specified type.

      Note that currently this method does not return blockless resources.
    examples: |
      # Returns all resources in the AST
      find_resources(ast)

      # Returns just the packages
      find_resources(ast, :type => :package)
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: param
        type: Hash
        name: options
        description: The options hash (see allowed values below)
      - category: option
        type: Symbol
        name: ':type'
        description: |
          The type of resource to look for (or `:any` for all resources)
      - category: return
        type: Array
        description: AST nodes of Chef resources.
  - name: included_recipes
    description: |
      Retrieve the recipes that are included within the given recipe AST.

      You can use this method to determine (and validate) recipe runtime
      dependencies.
    examples: |
      # Find all include_recipe statements, discarding the AST nodes to just
      # show the recipe names.
      included_recipes(ast).keys
      => ["postgresql::client"]

      included_recipes(ast, :with_partial_names => false).keys
      => ["postgresql::client"]
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The recipe AST
      - category: param
        type: Hash
        name: options
        description: |
          `:with_partial_names` - Include string literals for recipes that
          have embedded sub-expressions. This defaults to `true` for backward
          compatibility.
      - category: return
        type: Hash
        description: |
          Hash keyed by included recipe name where the value is the AST node  
          of the `include_recipe` statement.
  - name: literal_searches
    description: |
      Searches performed by the specified recipe that are literal strings.
      Searches with a query formed from a subexpression will be ignored.
    examples: |
      ast = read_ast('zenoss/recipes/server.rb')
      literal_searches(ast).size
      => 3
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: return
        type: Array
        description: The matching nodes
  - name: match
    description: |
      Create a match from the specified node.

      Return matches when a rule has matched against a recipe. A call to `match`
      is typically the last line of your rule.

      Ensure that the AST node you are passing to this method has a descendant
      `pos` node so that the match can be associated with a line in the file.
    examples: |
      # You will frequently use map to apply the match function to an array of
      # nodes that you consider matches for your rule.
      attribute_access(ast, :type => :string).map{|s| match(s)}
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: node
        description: The node to create a match for
      - category: return
        type: Hash
        description: |
          Hash with the matched node name and position with the recipe
  - name: notifications
    description: |
      Provides convenient access to resource notification details.
      You can pass either the AST for an individual resource or the entire
      recipe to this method. Note that a resource may be registered for
      multiple notifications / subscriptions.

      While Chef permits either `:immediate` or `:immediately` to be specified
      in cookbooks, the timing for both will be returned as `:immediate` to
      remove the need for callers to switch on both values.
    examples: |
      find_resources(ast).select do |resource|
        notifications(resource).any? do |notification|
          ! [:delayed, :immediate].include? notification[:timing]
        end
      end
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST to check for notifications.
      - category: return
        type: Array
        description: |
          A flat array of notification hashes.
          - `:type` - Either `:notifies` or `:subscribes`
          - `:resource_type` - The type of resource to be notified
          - `:resource_name` - The name of the resource to be notified. This
            can be an AST if the resource name is not a string literal.
          - `:action` - The notification action
          - `:timing` - Either `:delayed` or `:immediate`
          - `:style` - The syntax used in the cookbook to define the
            notification, either `:old` or `:new`
  - name: os_command?
    description: |
      Does the provided string look like an Operating System command? This is a
      rough heuristic to be taken with a pinch of salt.
    signature:
      - category: param
        type: String
        name: str
        description: The string to check
      - category: return
        type: Boolean
        description: |
          True if this string might be an OS command
  - name: read_ast
    description: |
      Read the AST for the given Ruby or Erb source file.

      Many of the other functions documented here take an `ast` as an argument.
      You can also use Nokogiri's support querying the AST with XPath or CSS
      to implement your own rules.
    examples: |
      # Normally the recipe AST will be passed in to your rule without you
      # needing to use read_ast.

      # However if you need to you can read in the AST for a cookbook recipe
      # directly.
      ast = read_ast('apache2/recipes/default.rb')
    signature:
      - category: param
        type: String
        name: file
        description: The file to read
      - category: return
        type: 'Nokogiri::XML::Node'
        description: |
          The recipe AST
  - name: resource_action?
    description: |
      Determine if an action is valid for the given resource type.
    examples: |
      resource_action?(:service, :restart)
      => true
    signature:
      - category: param
        type: Symbol
        name: resource_type
        description: The type of resource
      - category: param
        type: Symbol
        name: action
        description: The name of the action
      - category: return
        type: Boolean
        description: |
          True if the action is valid for this type of resource.
  - name: resource_attribute
    description: |
      Retrieve a single-valued attribute from the specified resource.
    examples: |
      # Given resource is a package
      resource_attribute(resource, 'action')
      => :install
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST to lookup the attribute under
      - category: param
        type: String
        name: name
        description: The attribute name
      - category: return
        type: String
        description: |
          The attribute value for the specified attribute
  - name: resource_attribute?
    description: |
      Is the specified attribute valid for the type of resource? Note that this
      method will return true if the `resource_type` is not recognised.
    examples: |
      resource_attribute?(:file, :mode) 
      => true

      resource_attribute?(:file, :size) 
      => false

      # If the resource is not a Chef built-in then the attribute is always
      # valid
      resource_attribute?(:my_custom_resource, :whatever) 
      => true
    signature:
      - category: param
        type: Symbol
        name: resource_type
        description: The type of Chef resource
      - category: param
        type: Symbol
        name: attribute_name
        description: The attribute name
      - category: return
        type: Boolean
        description: |
          True if the attribute is valid for this type of resource
  - name: resource_attributes
    description: |
      Retrieve all attributes from the specified resource.

      Use this method for convenient access to the resource attributes without
      needing to query the AST.
    examples: |
      resource_attributes(resource)
      => {:name=>"zenoss", "arch"=>"kernel", "action"=>:install}
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST
      - category: return
        type: Hash
        description: |
          The resource attributes
  - name: resource_attributes_by_type
    description: |
      Retrieve the attributes as a hash for all resources of a given type.

      Use this if you want to compare the attributes and values used by
      resources of the same type.
    examples: |
      # The values of the Hash (ignored here) are arrays of resource ASTs.
      resource_attributes_by_type(ast).keys.sort
      => ["apt_package",
       "apt_repository",
       "execute",
       "package",
       "ruby_block"]
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The recipe AST
      - category: return
        type: Hash
        description: |
          Resources keyed by type, with an array for each
  - name: resource_name
    description: |
      Retrieve the name attribute associated with the specified resource.
    examples: |
      resource_name(resource)
      => "zenoss"
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST to lookup the name attribute under
      - category: return
        type: String
        description: |
          The name attribute value
  - name: resource_type
    description: |
      Return the type, e.g. 'package' of a given resource.

      You could use this if you wanted to take different action in your rule
      based on the resource type.
    examples: |
      resource_type(resource)
      => "yum_package"
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST
      - category: return
        type: String
        description: |
          The type of resource
  - name: resources_by_type
    description: |
      Retrieve all resources of a given type.

      The key of the hash is the type of resource (as a string). The value is
      an array of Hashes.
    examples: |
      resources_by_type(ast).keys
      => ["yum_key",
       "yum_repository",
       "package",
       "service",
       "yum_package",
       "apt_repository",
       "apt_package"]
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The recipe AST
      - category: return
        type: Hash
        description: |
          The matching resources
  - name: ruby_code?
    description: |
      Does the provided string look like ruby code?
      This does not evaluate the expression, instead only checking that it
      appears syntactically valid.

      You can use this method to check that `ruby_block` resources and recipes
      themselves look like Ruby code.
    examples: |
      # Lots of strings are well-formed Ruby statements, including some strings
      # you might not expect:
      ruby_code?('System.out.println("hello world");')
      => true

      # This operating system command doesn't look like valid Ruby but others
      # might.
      ruby_code?('find -type f -print')
      => false
    signature:
      - category: param
        type: String
        name: str
        description: The string to check for rubiness
      - category: return
        type: Boolean
        description: |
          `True` if this string could be syntactically valid Ruby
  - name: searches
    description: |
      Searches performed by the specified recipe.
      In contrast to `literal_searches` this method returns all searches.

      You could use this method to identify all searches that search for a
      particular type of object, or to identify searches that are valid
      for a particular Chef version.
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check.
      - category: return
        type: Array
        description: |
          The AST nodes in the recipe where searches are performed
  - name: standard_cookbook_subdirs
    description: |
      The list of standard cookbook sub-directories.

      You can use this method when you need to traverse cookbooks manually
      yourself in order to determine directories to descend into.
    examples: |
      standard_cookbook_subdirs
      => ["attributes",
       "definitions",
       "files",
       "libraries",
       "providers",
       "recipes",
       "resources",
       "templates"]
    signature:
      - category: return
        type: Array
        description: |
          The standard list of directories.
  - name: valid_query?
    description: |
      Is this a valid Lucene query?

      Use this method when acting on searches in a recipe in order to check that
      they are valid before continuing with the rest of your rule.
    examples: |
      valid_query?('run_list:recipe[foo::bar]')
      => false

      valid_query?('run_list:recipe\[foo\:\:bar\]')
      => true
    signature:
      - category: param
        type: String
        name: query
        description: The query to check for syntax errors
      - category: return
        type: Boolean
        description: |
          `True` if the query is well-formed
---
<div class="container">
{% include masthead.html %}
<div class="page-header">
  <h1 id="why">Why? <small>What's all this about?</small></h1>
</div>
{% capture why %}{% include why.md %}{% endcapture %}{{ why | markdownify }}
{% include community-resources.html %}
{% include getting-started.html %}
{% include rules.html %}
<div class="page-header">
  <h1 id="faq">FAQ <small>Frequently Asked Questions</small></h1>
</div>
{% capture faq %}{% include faq.md %}{% endcapture %}{{ faq | markdownify }}
<div class="page-header">
  <h1 id="style">Style <small>Ruby styling with Tailor</small></h1>
</div>
{% capture style %}{% include style.md %}{% endcapture %}{{ style | markdownify }}
<div class="page-header">
  <h1 id="ci">Continuous Integration <small>Add linting to your deployment pipeline</small></h1>
</div>
<div class="page-header">
  <h2 id="travis">Travis <small>Configuring Travis to run foodcritic</small></h2>
</div>
{% capture travis %}{% include travis.md %}{% endcapture %}{{ travis | markdownify }}
<div class="page-header">
  <h2 id="jenkins">Jenkins <small>Configuring Jenkins to run foodcritic</small></h2>
</div>
{% capture jenkins %}{% include jenkins.md %}{% endcapture %}{{ jenkins | markdownify }}
<div class="page-header">
  <h2 id="build-framework-integration">Build Framework Integration <small>Running foodcritic from within your build</small></h2>
</div>
{% capture build_framework %}{% include build-framework.md %}{% endcapture %}{{ build_framework | markdownify }}
<div class="page-header">
  <h1 id="writing-a-new-rule">Extending foodcritic <small>Writing a new rule</small></h1>
</div>
{% capture newrule %}{% include new-rule.md %}{% endcapture %}{{ newrule | markdownify }}
{% include api.html %}
</div>
