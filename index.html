---
layout: default
title: Foodcritic
rules:
  - code: FC001
    name: Use strings in preference to symbols to access node attributes
    tags:
      - style
      - attributes
    summary: |
      Opscode recommend that you use strings rather than symbols when referencing node attributes.
      See [this explanation from @jtimberman](https://github.com/acrmp/foodcritic/issues/1).
    examples:
      - title: Uses symbols to reference attributes
        text: This example would match the FC001 rule because the `version` attribute has been referenced with a symbol.
        code: |
          # Don't do this
          package "mysql-server" do
            version node[:mysql][:version]
            action :install
          end
      - title: Modified version
        text: 'This modified example would not match the FC001 rule:'
        code: |
          package "mysql-server" do
            version node['mysql']['version']
            action :install
          end
  - code: FC002
    name: Avoid string interpolation where not required
    tags:
      - style
      - strings
    summary: |
      When you declare a resource in your recipes you frequently want to
      reference dynamic values such as node attributes. This warning will be
      shown if you are unnecessarily wrapping an attribute reference in a
      string.
    examples:
      - title: Unnecessary string interpolation
        text: This example would match the FC002 rule because the `version` attribute has been unnecessarily quoted.
        code: |
          # Don't do this
          package "mysql-server" do
            version "#{node['mysql']['version']}"
            action :install
          end
      - title: Modified version
        text: 'This modified example would not match the FC002 rule:'
        code: |
          package "mysql-server" do
            version node['mysql']['version']
            action :install
          end

  - code: FC003
    name: Check whether you are running with chef server before using server-specific features
    tags:
      - portability
      - solo
    summary: |
      Chef Server extends the feature-set of a Chef deployment and is probably
      the most popular configuration. It is also possible to run the Chef client
      in a standalone mode with Chef Solo.
      Where your cookbooks make use of features that only exist in a Chef Server
      based setup you should check whether you are running in solo mode.

      * [http://wiki.opscode.com/display/chef/Chef+Solo](http://wiki.opscode.com/display/chef/Chef+Solo)
    examples:
      - title: Does not check for Chef Solo
        text: |
          This example would match the FC003 rule because it does not check if
          it is running in Chef Solo before using search which is a
          server-specific feature.
        code: |
          nodes = search(:node, "hostname:[* TO *] AND chef_environment:#{node.chef_environment}")
      - title: Modified version
        text: 'This modified example would not match the FC003 rule:'
        code: |
          if Chef::Config[:solo]
            Chef::Log.warn("This recipe uses search. Chef Solo does not support search.")
          else
            nodes = search(:node, "hostname:[* TO *] AND chef_environment:#{node.chef_environment}")
          end
  - code: FC004
    name: Use a service resource to start and stop services
    tags:
      - style
      - services
    summary: |
      This warning is shown if you are starting or stopping a service using the
      Chef `execute` resource rather than the more idiomatic `service` resource.
      You can read more about the service resource here:

      * [http://wiki.opscode.com/display/chef/Resources#Resources-Service](http://wiki.opscode.com/display/chef/Resources#Resources-Service)
    examples:
      - title: Uses execute to control a service
        text: |
          This example would match the FC004 rule because it uses `execute` for
          service control. There is no reason to use execute because the service
          resource exposes the `start_command` attribute to give you full
          control over the command issued.
        code: |
          # Don't do this
          execute "start-tomcat" do
            command "/etc/init.d/tomcat6 start"
            action :run
          end
      - title: Modified version
        text: 'This modified example would not match the FC004 rule:'
        code: |
          service "tomcat" do
            action :start
          end
  - code: FC005
    name: Avoid repetition of resource declarations
    tags:
      - style
    summary: |
      When writing Chef recipes you have the full power of Ruby at your
      disposal. One of the cases where this is helpful is where you need to
      declare a large number of resources that only differ in a single attribute
      - the canonical example is installing a long list of packages.
    examples:
      - title: Unnecessarily repetitive
        text: |
          This example matches the FC005 rule because all the resources of type
          `package` differ only in a single attribute - the name of the package
          to be upgraded. This rule is very simple and looks only for resources
          that all differ in only a single attribute. For example - if only one
          of the packages specified the version then this rule would not match.
        code: |
          # You could do this
          package "erlang-base" do
            action :upgrade
          end
          package "erlang-corba" do
            action :upgrade
          end
          package "erlang-crypto" do
            action :upgrade
          end
          package "rabbitmq-server" do
            action :upgrade
          end
      - title: Modified version
        text: |
          This modified example would not match the FC005 rule. It takes
          advantage of the fact that Chef processes recipes in two distinct
          phases:

          * [http://wiki.opscode.com/display/chef/Anatomy+of+a+Chef+Run](http://wiki.opscode.com/display/chef/Anatomy+of+a+Chef+Run)

          Don't worry about changing your recipe if it already does what you
          want - the amount of Ruby syntactic sugar to apply is very much a
          matter of personal taste. Note that this rule also isn't clever enough
          yet to detect if your resources are wrapped in a control structure and
          not suitable for 'rolling up' into a loop.
        code: |
          # It's shorter to do this
          %w{erlang-base erlang-corba erlang-crypto rabbitmq-server}.each do |pkg|
            package pkg do
              action :upgrade
            end
          end
  - code: FC006
    name: Mode should be quoted or fully specified when setting file permissions
    tags:
      - correctness
      - files
    summary: |
      When setting file or directory permissions via the mode attribute you
      should either quote the octal number or ensure it is specified to five
      digits. Otherwise the permissions that are set after Ruby coerces the
      number may not match what you expect.
    examples:
      - title: File mode won't be interpreted correctly
        code: |
          # Don't do this
          directory "/var/lib/foo" do
            owner "root"
            group "root"
            mode 644
            action :create
          end
      - title: Modified versions
        text: 'These modified examples would not match the FC006 rule:'
        code: |
          # This is ok
          directory "/var/lib/foo" do
            owner "root"
            group "root"
            mode "644"
            action :create
          end

          # And so is this
          directory "/var/lib/foo" do
            owner "root"
            group "root"
            mode 00644
            action :create
          end
  - code: FC007
    name: Ensure recipe dependencies are reflected in cookbook metadata
    tags:
      - correctness
      - metadata
    summary: |
      This warning is shown when you include a recipe that is not in the current
      cookbook and not defined as a dependency in your cookbook metadata. This
      is potentially a big problem because things will blow up if the necessary
      dependency cannot be found when Chef tries to converge your node. For more
      information refer to the Chef wiki metadata page:

      * [http://wiki.opscode.com/display/chef/Metadata](http://wiki.opscode.com/display/chef/Metadata)

      The fix is to declare the cookbook of the recipe you are including as a
      dependency in your `metadata.rb` file.

      You may also see this warning if foodcritic has not been able to infer the
      name of your cookbook correctly when the cookbook directory does not match
      the name of the cookbook specified in the include.
    examples:
      - title: Example depency on another cookbook
        text: |
          Assuming you have a recipe that had the following line:
        code: |
          include_recipe "apache2::default"
      - title: Adding metadata dependency for Chef
        text: |
          Then to remove this warning you would add the `apache2` cookbook as a
          dependency to your own cookbook metadata in the `metadata.rb` file at
          the root of your cookbook.
        code: |
          depends "apache2"
  - code: FC008
    name: Generated cookbook metadata needs updating
    tags:
      - style
      - metadata
    summary: |
      This warning is shown if you used `knife cookbook create` to create a new
      cookbook and didn't override the maintainer and maintainer email. You need
      to set these to real values in `metadata.rb` or run knife again with the
      real values.

      * [http://wiki.opscode.com/display/chef/Managing+Cookbooks+With+Knife#ManagingCookbooksWithKnife-create](http://wiki.opscode.com/display/chef/Managing+Cookbooks+With+Knife#ManagingCookbooksWithKnife-create)
    examples:
      - title: Maintainer metadata is boilerplate default
        code: |
          # Don't do this
          maintainer "YOUR_COMPANY_NAME"
          maintainer_email "YOUR_EMAIL"
          license "All rights reserved"
          description "Installs/Configures example"
          long_description IO.read(File.join(File.dirname(__FILE__), 'README.rdoc'))
          version "0.0.1"
      - title: Modified version
        text: 'This modified example would not match the FC008 rule:'
        code: |
          maintainer "Example Ltd"
          maintainer_email "postmaster@example.com"
          license "All rights reserved"
          description "Installs/Configures example"
          long_description IO.read(File.join(File.dirname(__FILE__), 'README.rdoc'))
          version "0.0.1"
  - code: FC009
    name: Resource attribute not recognised
    tags:
      - correctness
    summary: |
        This warning is likely to mean that your recipe will fail to run when
        you attempt to converge. Your recipe may be syntactically valid Ruby,
        but the attribute you have attempted to set on a built-in Chef resource
        is not recognised. This is commonly a typo or you need to check the
        documentation to see what the attribute you are trying to set is called:

        * [http://wiki.opscode.com/display/chef/Resources](http://wiki.opscode.com/display/chef/Resources)
    examples:
      - title: Resource with an unrecognised attribute
        text: |
          This example matches the FC009 rule because `punter` is not a
          recognised attribute for the file resource.
        code: |
          # Don't do this
          file "/tmp/something" do
            punter "root"
            group "root"
            mode "0755"
            action :create
          end
      - title: Modified version
        text: |
          Checking the documentation we can see the correct attribute is
          `owner`.
        code: |
          file "/tmp/something" do
            owner "root"
            group "root"
            mode "0755"
            action :create
          end
  - code: FC010
    name: Invalid search syntax
    tags:
      - correctness
      - search
    summary: |
      The search syntax used is not recognised as valid Lucene search criteria.
      This is commonly because you have made a typo or are not escaping special
      characters in the query syntax.

      * [http://wiki.opscode.com/display/chef/Search#Search-QuerySyntax](http://wiki.opscode.com/display/chef/Search#Search-QuerySyntax)

      Note that this rule will not identify syntax errors in searches composed
      of subexpressions. It checks only for literal search strings.
    examples:
      - title: Unescaped search syntax
        text: |
          This example matches the FC010 rule because search metacharacters -
          in this case the square brackets - have not been properly escaped.
        code: |
          # Don't do this
          search(:node, 'run_list:recipe[foo::bar]') do |matching_node|
            puts matching_node.to_s
          end
      - title: Modified version
        text: |
          With the characters escaped this will no longer match the rule.
        code: |
          search(:node, 'run_list:recipe\[foo\:\:bar\]') do |matching_node|
            puts matching_node.to_s
          end
  - code: FC011
    name: Missing README in markdown format
    tags:
      - style
      - readme
    summary: |
      The [Opscode Community site](http://community.opscode.com/) will now
      render your cookbook README documentation inline - [see this example for
      the mysql cookbook](http://community.opscode.com/cookbooks/mysql).

      Your README needs to be in
      [Markdown format](http://daringfireball.net/projects/markdown/syntax) for
      this to work. This rule will match any cookbook that does not have a
      `README.md` file in the root directory.
  - code: FC012
    name: Use Markdown for README rather than RDoc
    tags:
      - style
      - readme
    summary: |
      Writing cookbook documentation in RDoc has been deprecated in favour of
      [Markdown format](http://daringfireball.net/projects/markdown/syntax).
      This rule will match any cookbook that has a `README.rdoc` file in the
      root directory.
  - code: FC013
    name: Use file_cache_path rather than hard-coding tmp paths
    tags:
      - style
      - files
    summary: |
      This warning means that you have hard-coded a file download path in your
      cookbook to a temporary directory. This can be a problem on boxes built
      with a small `/tmp` mount point. Chef has its own configuration option
      `file_cache_path` you should use instead:

      * [http://wiki.opscode.com/display/chef/Chef+Configuration+Settings#ChefConfigurationSettings-filecachepath](http://wiki.opscode.com/display/chef/Chef+Configuration+Settings#ChefConfigurationSettings-filecachepath)
    examples:
      - title: Downloading to a hard-coded temp directory
        text: |
          This example matches the FC013 rule because it hard-codes the download
          path to `/tmp`.
        code: |
          # Don't do this
          remote_file "/tmp/large-file.tar.gz" do
            source "http://www.example.org/large-file.tar.gz"
          end
      - title: Modified version
        text: 'To remove this warning use the configured `file_cache_path`:'
        code: |
          remote_file "#{Chef::Config[:file_cache_path]}/large-file.tar.gz" do
            source "http://www.example.org/large-file.tar.gz"
          end
  - code: FC014
    name: Consider extracting long ruby_block to library
    tags:
      - style
      - libraries
    summary: |
      Your cookbook has a fairly long `ruby_block` resource. Long `ruby_block`
      resources are often candidates for extraction to a separate module or
      class under the `libraries` directory.

      * [http://wiki.opscode.com/display/chef/Libraries](http://wiki.opscode.com/display/chef/Libraries)
  - code: FC015
    name: Consider converting definition to a LWRP
    tags:
      - style
      - definitions
      - lwrp
    summary: |
      Chef definitions are an older approach to creating a higher-level
      abstraction for a group of resources. Unlike LWRPs they are not first
      class resources and cannot receive notifications. You should prefer LWRPs
      for new development.

      * [http://wiki.opscode.com/display/chef/Definitions](http://wiki.opscode.com/display/chef/Definitions)
      * [http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+(LWRP)](http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+%28LWRP%29)
  - code: FC016
    name: LWRP does not declare a default action
    tags:
      - correctness
      - lwrp
    summary: |
      This warning means that the LWRP does not declare a default action. You
      should normally define a default action on your resource to avoid
      confusing users. Most resources have an intuitive default action.

      * [http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+(LWRP)#LightweightResourcesandProviders%28LWRP%29-DefaultAction](http://wiki.opscode.com/display/chef/Lightweight+Resources+and+Providers+%28LWRP%29#LightweightResourcesandProviders%28LWRP%29-DefaultAction)
    examples:
      - title: Resource without a default action
        text: |
          This example matches the FC016 rule because it does not declare a
          default action.
        code: |
          # Don't do this
          actions :create
      - title: Modified version
        text: |
          With a default action specified this warning will no longer be
          displayed.
        code: |
          actions :create

          # Chef 0.10.10 or greater
          default_action :create
          
          # In earlier versions of Chef the LWRP DSL doesn't support specifying
          # a default action, so you need to drop into Ruby.
          def initialize(*args)
            super
            @action = :create
          end
  - code: FC017
    name: LWRP does not notify when updated
    tags:
      - correctness
      - lwrp
    summary: |
      This warning means that the LWRP will not currently trigger notifications
      to other resources. This can be a source of difficult to track down bugs.

      * [http://wiki.opscode.com/display/chef/Resources#Resources-Notifications](http://wiki.opscode.com/display/chef/Resources#Resources-Notifications)
    examples:
      - title: Provider that does not send notifications
        text: |
          This example matches the FC017 rule because it does not mark that its
          state has changed and will therefore not send notifications.
        code: |
          # Don't do this
          action :create do
            # create action implementation
          end
      - title: Modified version
        text: |
          The call to `updated_by_last_action` ensures that notifications will
          work correctly.
        code: |
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers
            new_resource.updated_by_last_action(true)
          end
  - code: FC018
    name: LWRP uses deprecated notification syntax
    tags:
      - style
      - lwrp
      - deprecated
    examples:
      - title: Provider uses deprecated syntax
        text: |
          This example matches the FC018 rule because it uses the old syntax for
          indicating it has been updated.
        code: |
          # Don't do this
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers, but I'm using
            # a deprecated syntax
            new_resource.updated = true
          end

          # Also don't do this
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers, but I'm using
            # a deprecated syntax
            @updated = true
          end
      - title: Modified version
        text: |
          This example uses the newer syntax and will not raise the warning.
        code: |
          action :create do
            # create action implementation
          
            # My state has changed so I'd better notify observers
            new_resource.updated_by_last_action(true)
          end
  - code: FC019
    name: Access node attributes in a consistent manner
    tags:
      - style
      - attributes
    summary: |
      Node attributes can be accessed in multiple ways in Chef. This warning is
      shown when a cookbook is not consistent in the approach it uses to access
      attributes. It is not displayed for variations between cookbooks.
    examples:
      - title: Recipe mixes symbols and strings for accessing node attributes
        code: |
          # Don't do this
          node[:apache][:dir] = '/etc/apache2'
          
          directory node['apache']['dir'] do
            owner 'apache'
            group 'apache'
            action :create
          end
      - title: Modified version
        code: |
          node['apache']['dir'] = '/etc/apache2'
          
          directory node['apache']['dir'] do
            owner 'apache'
            group 'apache'
            action :create
          end
  - code: FC020
    name: Conditional execution string attribute looks like Ruby
    tags:
      - correctness
    summary: |
      When specifying an `only_if` or `not_if` attribute for conditional
      execution of your resource you have the option of either a command string
      or Ruby block. This warning is shown when your condition is passed as a
      string but looks like a Ruby block.

      * [http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
    examples:
      - title: Passes Ruby block condition as string
        code: |
          # Don't do this
          execute "my_random_command" do
            action :run
            not_if "::File.directory?(node[:foo])"
          end
      - title: Modified version
        code: |
          execute "my_random_command" do
            action :run
            not_if { ::File.directory?(node[:foo]) }
          end
  - code: FC021
    name: Resource condition in provider may not behave as expected
    tags:
      - correctness
      - lwrp
    summary: |
      A change introduced in Chef 0.10.6 means that conditions may not work as
      expected for resources redeclared with the same name. If your LWRP defines
      a resource and that resource:

      * Has an [associated condition](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
        which references a resource attribute. AND
      * The resource has a fixed name.

      Then you will likely find that only the first resource will be applied. See this ticket for more background:

      * [http://tickets.opscode.com/browse/CHEF-2812](http://tickets.opscode.com/browse/CHEF-2812)
    examples:
      - title: Resource condition will be evaluated only once
        text: |
          Because the `feed_pet` resource will have the same name across all
          instances of your LWRP, the condition will only be checked for the
          first resource.
        code: |
          # Don't do this
          action :feed do
            execute "feed_pet" do
              command "echo 'Feeding: #{new_resource.name}'; touch '/tmp/#{new_resource.name}'"
              not_if { ::File.exists?("/tmp/#{new_resource.name}")}
            end
          end
      - title: Modified version
        text: |
          By making the resource name change for each unique instance of our
          LWRP instance we avoid this behaviour.
        code: |
          action :feed do
            execute "feed_pet_#{new_resource.name}" do
              command "echo 'Feeding: #{new_resource.name}'; touch '/tmp/#{new_resource.name}'"
              not_if { ::File.exists?("/tmp/#{new_resource.name}")}
            end
          end
  - code: FC022
    name: Resource condition within loop may not behave as expected
    tags:
      - correctness
    summary: |
      A change introduced in Chef 0.10.6 means that conditions may not work as
      expected for resources declared within a loop. If your recipe defines a
      resource and that resource:

      * Has an [associated condition](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
        which references a block variable. AND
      * The resource has a fixed name.

      Then you will likely find that only the first resource will be applied. See this ticket for more background:

      * [http://tickets.opscode.com/browse/CHEF-2812](http://tickets.opscode.com/browse/CHEF-2812)
    examples:
      - title: Resource condition will be evaluated only once
        text: |
          Because the feed_pet resource will have the same name for every
          iteration of the loop, the condition will only be checked for the
          first resource.
        code: |
          # Don't do this
          %w{rover fido}.each do |pet_name|
            execute "feed_pet" do
              command "echo 'Feeding: #{pet_name}'; touch '/tmp/#{pet_name}'"
              not_if { ::File.exists?("/tmp/#{pet_name}")}
            end
          end
      - title: Modified version
        text: |
          By making the resource name change for each iteration of the loop we avoid this behaviour.
        code: |
          %w{rover fido}.each do |pet_name|
            execute "feed_pet_#{pet_name}" do
              command "echo 'Feeding: #{pet_name}'; touch '/tmp/#{pet_name}'"
              not_if { ::File.exists?("/tmp/#{pet_name}")}
            end
          end
  - code: FC023
    name: Prefer conditional attributes
    tags:
      - style
    summary: |
      This warning means you have surrounded a resource with an `if` or `unless`
      rather than defining the condition directly on the resource itself. Note
      that this warning is only raised for single resources as you could
      reasonably enclose multiple resources in a condition like this for
      brevity.
    examples:
      - title: Resource enclosed in a condition
        text: |
          This example matches the FC023 rule because it encloses a rule within
          a condition, rather than using the built-in Chef `not_if` or `only_if`
          conditional execution attributes.

          * [http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution](http://wiki.opscode.com/display/chef/Resources#Resources-ConditionalExecution)
        code: |
          # Don't do this
          if node['foo'] == 'bar'
            service "apache" do
              action :enable
            end
          end
      - title: Modified version
        text: |
          You can avoid the warning above with more idiomatic Chef that
          specifies the condition above as an attribute on the resource:
        code: |
          service "apache" do
            action :enable
            only_if { node['foo'] == 'bar'}
          end
  - code: FC024
    name: Consider adding platform equivalents
    tags:
      - portability
    summary: |
      This warning is shown when:

      * you have a conditional statement in your cookbook based on the platform
        of the node
      * and at least two platforms are included as equivalent in your
        conditional
      * and the conditional does not include a platform known to belong to the
        same family

      If you are using
      [Ohai 0.6.12](http://www.opscode.com/blog/2012/03/22/ohai-0-6-12-released/)
      or greater you should probably use `platform_family` instead. Otherwise
      for the greatest portability consider adding the missing platforms to
      your conditional.
    examples:
      - title: Case statement has a subset of platform flavours
        text: |
          This example matches the FC024 rule because it includes a `case`
          statement that matches more than one flavour of a platform family
          but omits other popular flavours from the same family.
        code: |
          # The RHEL platforms branch below omits popular distributions
          # including Amazon Linux.
          case node[:platform]
            when "debian", "ubuntu"
              package "foo" do
                action :install
              end
            when "centos", "redhat"
              package "bar" do
                action :install
              end
            end
          end
      - title: Modified version
        text: |
          This warning is no longer raised when the other common equivalent
          RHEL-based distributions have been added to the `when`.
        code: |
          case node[:platform]
            when "debian", "ubuntu"
              package "foo" do
                action :install
              end
            when "centos", "redhat", "amazon", "scientific"
              package "bar" do
                action :install
              end
            end
  - code: FC025
    name: Prefer chef_gem to compile-time gem install
    tags:
      - style
      - deprecated
    summary: |
      This warning is shown if:
      * you have a cookbook that installs a Rubygem for use from Chef
      * the cookbook uses the
        [compile-time gem install trick](http://www.opscode.com/blog/2009/06/01/cool-chef-tricks-install-and-use-rubygems-in-a-chef-run/)
        which is deprecated from Chef 0.10.10 and is replaced by the first class
        `chef_gem` resource.
    examples:
      - title: Manual compile-time installation
        text: |
          This example matches the FC025 rule because it uses the older
          approach for installing a gem so that it is available in the current
          run.
        code: |
          r = gem_package "mysql" do
            action :nothing
          end

          r.run_action(:install)
          Gem.clear_paths
      - title: Modified version
        text: |
          Use `chef_gem` to install the gem to avoid this warning.
        code: |
          chef_gem "mysql"
  - code: FC026
    name: Conditional execution block attribute contains only string
    tags:
      - correctness
    summary: |
      This warning is shown if you have a conditional attribute declared on a
      resource as a block that contains only a single string.
    examples:
      - title: Conditional attribute returns a string
        text: |
          This example matches the FC026 rule because it returns a string from
          the block. This will always evalute to true, and often indicates that
          you are trying to run a command rather than execute a Ruby block as
          your condition.
        code: |
          # Don't do this
          template "/etc/foo" do
            mode "0644"
            source "foo.erb"
            not_if { "test -f /etc/foo" }
          end
      - title: Modified version
        text: |
          If the intention is to run the string as an operating system command
          then remove the block surrounding the command.
        code: |
          template "/etc/foo" do
            mode "0644"
            source "foo.erb"
            not_if "test -f /etc/foo"
          end

api_methods: 
  - name: attribute_access
    description: |
      Find attributes accesses by type.

      You might use this method to enforce local style rules on how attributes
      are accessed.
    examples: |
      # All references to attributes using strings
      # For example: node['foo']
      attribute_access(ast, :type => :string)
      
      # All references to attributes using symbols
      # For example: node[:foo]
      attribute_access(ast, :type => :symbol)
      
      # All references to attributes using dots (vivified methods)
      # For example: node.foo
      attribute_access(ast, :type => :symbol)
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: param
        type: Hash
        name: options
        description: The options hash (see allowed values below)
      - category: option
        type: Symbol
        name: ':type'
        description: |
          The approach used to access the attributes. One of `:string`,
          `:symbol` or `:vivified`.
      - category: option
        type: Boolean
        name: ':ignore_calls'
        description: |
          Exclude attribute accesses that mix strings/symbols with dot notation.
          Defaults to `false`.
      - category: return
        type: Array
        description: The matching nodes if any
  - name: checks_for_chef_solo?
    description: |
      Does the specified recipe check for
      [Chef Solo](http://wiki.opscode.com/display/chef/Chef+Solo)?

      You can use this to check for the portability of the recipe between
      Chef Server and Chef Solo.
    examples: |
      # Returns true if the recipe checks for Chef Solo before using
      # server-specific functionality.
      checks_for_chef_solo?(ast)
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: return
        type: Boolean
        description: |
          True if there is a test for `Chef::Config[:solo]` in the recipe
  - name: chef_dsl_methods
    description: |
      The set of methods in the Chef DSL.

      You can use this to see if a method reference is part of the Chef DSL or
      defined in a cookbook.
    examples: |
      # Is search a method in the Chef DSL?
      chef_dsl_methods.include?(:search)
      => true
    signature:
      - category: return
        type: Array
        description: |
          Array of method symbols
  - name: chef_solo_search_supported?
    description: |
      Is the [chef-solo-search](https://github.com/edelight/chef-solo-search) library available?

      Will return `true` if any cookbook in the cookbook tree relative to the
      specified recipe includes the chef-solo-search library. You can use this
      to see if search is available in Chef Solo mode.
    examples: |
      # True if chef_solo_search is supported
      chef_solo_search_supported?('foo/recipes/default.rb')
    signature:
      - category: param
        type: String
        name: recipe_path
        description: The path to the current recipe
      - category: return
        type: Boolean
        description: True if the chef-solo-search library is available.
  - name: cookbook_name
    description: |
      The name of the cookbook containing the specified file.

      You can use this method in rules that need to work out if recipe code
      refers to the current cookbook: for example when looking at
      `included_recipe` statements or LWRP usage.
    examples: |
      cookbook_name('foo/recipes/default.rb')
      => "foo"
    signature:
      - category: param
        type: String
        name: file
        description: The file in the cookbook
      - category: return
        type: String
        description: The name of the containing cookbook
  - name: declared_dependencies
    description: |
      The dependencies declared in cookbook metadata.

      You can use this to check if all dependencies have been declared
      correctly or to find all cookbooks that share a common dependency.
    examples: |
      ast = read_ast('postgresql/metadata.rb')
      declared_dependencies(ast)
      => ["openssl"]
    signature:
      - category: param
        type: Nokogiri::XML::Node
        name: ast
        description: The metadata rb AST
      - category: return
        type: Array
        description: List of cookbooks depended on
  - name: file_match
    description: |
      Create a match for a specified file. Use this if the presence of the file
      triggers the warning rather than content.

      This is an alternative to `match` where you don't have a specific AST
      element to associate the warning with. The call to `file_match` will
      typically be the last line in your rule.
    examples: |
      file_match('foo/recipes/default.rb')
      => {:filename=>"foo/recipes/default.rb",
       :matched=>"foo/recipes/default.rb",
       :line=>1,
       :column=>1}
    signature:
      - category: param
        type: String
        name: file
        description: The filename to create a match for
      - category: return
        type: Hash
        description: Hash with the match details
  - name: find_resources
    description: |
      Find Chef resources of the specified type.

      Note that currently this method does not return blockless resources.
    examples: |
      # Returns all resources in the AST
      find_resources(ast)

      # Returns just the packages
      find_resources(ast, :type => :package)
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: param
        type: Hash
        name: options
        description: The options hash (see allowed values below)
      - category: option
        type: Symbol
        name: ':type'
        description: |
          The type of resource to look for (or `:any` for all resources)
      - category: return
        type: Array
        description: AST nodes of Chef resources.
  - name: included_recipes
    description: |
      Retrieve the recipes that are included within the given recipe AST.

      You can use this method to determine (and validate) recipe runtime
      dependencies.
    examples: |
      # Find all include_recipe statements, discarding the AST nodes to just
      # show the recipe names.
      included_recipes(ast).keys
      => ["postgresql::client"]
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The recipe AST
      - category: return
        type: Hash
        description: |
          Hash keyed by included recipe name where the value is the AST node  
          of the `include_recipe` statement.
  - name: literal_searches
    description: |
      Searches performed by the specified recipe that are literal strings.
      Searches with a query formed from a subexpression will be ignored.
    examples: |
      ast = read_ast('zenoss/recipes/server.rb')
      literal_searches(ast).size
      => 3
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check
      - category: return
        type: Array
        description: The matching nodes
  - name: match
    description: |
      Create a match from the specified node.

      Return matches when a rule has matched against a recipe. A call to `match`
      is typically the last line of your rule.

      Ensure that the AST node you are passing to this method has a descendant
      `pos` node so that the match can be associated with a line in the file.
    examples: |
      # You will frequently use map to apply the match function to an array of
      # nodes that you consider matches for your rule.
      attribute_access(ast, :type => :string).map{|s| match(s)}
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: node
        description: The node to create a match for
      - category: return
        type: Hash
        description: |
          Hash with the matched node name and position with the recipe
  - name: os_command?
    description: |
      Does the provided string look like an Operating System command? This is a
      rough heuristic to be taken with a pinch of salt.
    signature:
      - category: param
        type: String
        name: str
        description: The string to check
      - category: return
        type: Boolean
        description: |
          True if this string might be an OS command
  - name: read_ast
    description: |
      Read the AST for the given Ruby source file.

      Many of the other functions documented here take an `ast` as an argument.
      You can also use Nokogiri's support querying the AST with XPath or CSS
      to implement your own rules.
    examples: |
      # Normally the recipe AST will be passed in to your rule without you
      # needing to use read_ast.

      # However if you need to you can read in the AST for a cookbook recipe
      # directly.
      ast = read_ast('apache2/recipes/default.rb')
    signature:
      - category: param
        type: String
        name: file
        description: The file to read
      - category: return
        type: 'Nokogiri::XML::Node'
        description: |
          The recipe AST
  - name: resource_attribute
    description: |
      Retrieve a single-valued attribute from the specified resource.
    examples: |
      # Given resource is a package
      resource_attribute(resource, 'action')
      => :install
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST to lookup the attribute under
      - category: param
        type: String
        name: name
        description: The attribute name
      - category: return
        type: String
        description: |
          The attribute value for the specified attribute
  - name: resource_attribute?
    description: |
      Is the specified attribute valid for the type of resource? Note that this
      method will return true if the `resource_type` is not recognised.
    examples: |
      resource_attribute?(:file, :mode) 
      => true

      resource_attribute?(:file, :size) 
      => false

      # If the resource is not a Chef built-in then the attribute is always
      # valid
      resource_attribute?(:my_custom_resource, :whatever) 
      => true
    signature:
      - category: param
        type: Symbol
        name: resource_type
        description: The type of Chef resource
      - category: param
        type: Symbol
        name: attribute_name
        description: The attribute name
      - category: return
        type: Boolean
        description: |
          True if the attribute is valid for this type of resource
  - name: resource_attributes
    description: |
      Retrieve all attributes from the specified resource.

      Use this method for convenient access to the resource attributes without
      needing to query the AST.
    examples: |
      resource_attributes(resource)
      => {:name=>"zenoss", "arch"=>"kernel", "action"=>:install}
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST
      - category: return
        type: Hash
        description: |
          The resource attributes
  - name: resource_attributes_by_type
    description: |
      Retrieve the attributes as a hash for all resources of a given type.

      Use this if you want to compare the attributes and values used by
      resources of the same type.
    examples: |
      # The values of the Hash (ignored here) are arrays of resource ASTs.
      resource_attributes_by_type(ast).keys.sort
      => ["apt_package",
       "apt_repository",
       "execute",
       "package",
       "ruby_block"]
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The recipe AST
      - category: return
        type: Hash
        description: |
          Resources keyed by type, with an array for each
  - name: resource_name
    description: |
      Retrieve the name attribute associated with the specified resource.
    examples: |
      resource_name(resource)
      => "zenoss"
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST to lookup the name attribute under
      - category: return
        type: String
        description: |
          The name attribute value
  - name: resource_type
    description: |
      Return the type, e.g. 'package' of a given resource.

      You could use this if you wanted to take different action in your rule
      based on the resource type.
    examples: |
      resource_type(resource)
      => "yum_package"
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: resource
        description: The resource AST
      - category: return
        type: String
        description: |
          The type of resource
  - name: resources_by_type
    description: |
      Retrieve all resources of a given type.

      The key of the hash is the type of resource (as a string). The value is
      an array of Hashes.
    examples: |
      resources_by_type(ast).keys
      => ["yum_key",
       "yum_repository",
       "package",
       "service",
       "yum_package",
       "apt_repository",
       "apt_package"]
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The recipe AST
      - category: return
        type: Hash
        description: |
          The matching resources
  - name: ruby_code?
    description: |
      Does the provided string look like ruby code?
      This does not evaluate the expression, instead only checking that it
      appears syntactically valid.

      You can use this method to check that `ruby_block` resources and recipes
      themselves look like Ruby code.
    examples: |
      # Lots of strings are well-formed Ruby statements, including some strings
      # you might not expect:
      ruby_code?('System.out.println("hello world");')
      => true

      # This operating system command doesn't look like valid Ruby but others
      # might.
      ruby_code?('find -type f -print')
      => false
    signature:
      - category: param
        type: String
        name: str
        description: The string to check for rubiness
      - category: return
        type: Boolean
        description: |
          `True` if this string could be syntactically valid Ruby
  - name: searches
    description: |
      Searches performed by the specified recipe.
      In contrast to `literal_searches` this method returns all searches.

      You could use this method to identify all searches that search for a
      particular type of object, or to identify searches that are valid
      for a particular Chef version.
    signature:
      - category: param
        type: 'Nokogiri::XML::Node'
        name: ast
        description: The AST of the cookbook recipe to check.
      - category: return
        type: Array
        description: |
          The AST nodes in the recipe where searches are performed
  - name: standard_cookbook_subdirs
    description: |
      The list of standard cookbook sub-directories.

      You can use this method when you need to traverse cookbooks manually
      yourself in order to determine directories to descend into.
    examples: |
      standard_cookbook_subdirs
      => ["attributes",
       "definitions",
       "files",
       "libraries",
       "providers",
       "recipes",
       "resources",
       "templates"]
    signature:
      - category: return
        type: Array
        description: |
          The standard list of directories.
  - name: valid_query?
    description: |
      Is this a valid Lucene query?

      Use this method when acting on searches in a recipe in order to check that
      they are valid before continuing with the rest of your rule.
    examples: |
      valid_query?('run_list:recipe[foo::bar]')
      => false

      valid_query?('run_list:recipe\[foo\:\:bar\]')
      => true
    signature:
      - category: param
        type: String
        name: query
        description: The query to check for syntax errors
      - category: return
        type: Boolean
        description: |
          `True` if the query is well-formed
---
<div class="container">
{% include masthead.html %}
<div class="page-header">
  <h1 id="why">Why? <small>What's all this about?</small></h1>
</div>
{% capture why %}{% include why.md %}{% endcapture %}{{ why | markdownify }}
{% include getting-started.html %}
{% include rules.html %}
<div class="page-header">
  <h1 id="faq">FAQ <small>Frequently Asked Questions</small></h1>
</div>
{% capture faq %}{% include faq.md %}{% endcapture %}{{ faq | markdownify }}
<div class="page-header">
  <h1 id="ci">Continuous Integration <small>Configuring Jenkins to run foodcritic</small></h1>
</div>
{% capture ci %}{% include ci.md %}{% endcapture %}{{ ci | markdownify }}
<div class="page-header">
  <h1 id="writing-a-new-rule">Extending foodcritic <small>Writing a new rule</small></h1>
</div>
{% capture newrule %}{% include new-rule.md %}{% endcapture %}{{ newrule | markdownify }}
{% include api.html %}
<div class="page-header">
  <h1 id="style">Style<small>Ruby styling with Tailor</small></h1>
</div>
{% capture style %}{% include style.md %}{% endcapture %}{{ style | markdownify }}
</div>
